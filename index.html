<!DOCTYPE html>
<html lang="zh-CN" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¤§æ•°ç ´å£ï¼šç©¶æå¯¹å†³</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
        
        :root {
            --bg-color: #050505;
            --lane-bg: #0a0a0a;
            --text-color: #fff;
            --text-dim: #aaa;
            --divider-color: #333;
            --wall-bg: #fff;
            --wall-text: #000;
            --wall-shadow: rgba(255,255,255,0.2);
            --wall-gravitized: #2a0a3d;
            --wall-gravitized-text: #fff;
            --wall-hit: #ffcccc;
            --wall-holy: #fffacd;
            --wall-venom: #ccffcc;
            --panel-bg: rgba(10, 10, 10, 0.95);
            --panel-border: #333;
            --input-bg: #1a1a1a;
            --input-border: #444;
            --scanline-opacity: 0.1;
            --bubble-bg: rgba(255, 255, 255, 0.9);
            --bubble-text: #000;
        }

        [data-theme="light"] {
            --bg-color: #e0e0e0;
            --lane-bg: #f5f5f5;
            --text-color: #111;
            --text-dim: #555;
            --divider-color: #ccc;
            --wall-bg: #333;
            --wall-text: #fff;
            --wall-shadow: rgba(0,0,0,0.2);
            --wall-gravitized: #e0d0f0;
            --wall-gravitized-text: #000;
            --wall-hit: #ff9999;
            --wall-holy: #ffffcc;
            --wall-venom: #004400;
            --panel-bg: rgba(255, 255, 255, 0.95);
            --panel-border: #ccc;
            --input-bg: #fff;
            --input-border: #ccc;
            --scanline-opacity: 0.03;
            --bubble-bg: rgba(0, 0, 0, 0.9);
            --bubble-text: #fff;
        }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            touch-action: none;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            transition: background-color 0.3s, color 0.3s;
        }

        /* CRT Scanline Effect */
        .scanlines {
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, var(--scanline-opacity)) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 50;
        }

        /* Header Bar */
        .game-header {
            height: 80px;
            background-color: var(--bg-color);
            border-bottom: 2px solid var(--divider-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2rem;
            z-index: 20;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            position: relative;
        }

        .player-stats {
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-width: 150px;
        }
        
        .p1-stats { align-items: flex-start; text-align: left; }
        .p2-stats { align-items: flex-end; text-align: right; }

        .vs-badge {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--text-dim);
            opacity: 0.5;
        }

        .theme-toggle {
            position: absolute;
            bottom: 20px; 
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            border: 1px solid var(--input-border);
            color: var(--text-color);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5rem;
            transition: all 0.2s;
            z-index: 60;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        .theme-toggle:hover {
            background-color: var(--input-bg);
            transform: translateX(-50%) scale(1.1);
        }

        .game-container {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 2px 1fr;
            background-color: var(--bg-color);
            position: relative;
            overflow: hidden;
            transition: all 1s ease;
        }
        
        .game-container.singularity-mode {
             grid-template-columns: 1fr;
        }
        .game-container.singularity-mode .lane-divider {
            display: none;
        }
        .game-container.singularity-mode .lane {
            border: none;
            background: transparent;
            overflow: visible;
        }

        .lane {
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background: var(--lane-bg);
            transition: background-color 0.3s;
        }

        .lane-divider {
            background: linear-gradient(to bottom, transparent, var(--divider-color), var(--divider-color), transparent);
            width: 2px;
            transition: opacity 1s;
        }

        .ball-name {
            font-size: 1.1rem;
            font-weight: bold;
            text-shadow: 0 0 5px currentColor;
        }

        .ball-damage {
            font-size: 0.9rem;
            color: var(--text-dim);
            margin-top: 4px;
            font-family: 'Courier New', Courier, monospace;
        }

        /* Walls Area */
        .walls-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .wall {
            position: absolute;
            left: 5%;
            width: 90%;
            height: 60px;
            background: var(--wall-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--wall-text);
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 0 10px var(--wall-shadow);
            transition: transform 0.1s, width 0.2s, height 0.2s, top 0.2s, left 0.2s, border-color 0.2s;
            border-radius: 4px;
            z-index: 2; 
            border: 2px solid transparent; /* Initial border for transition */
        }
        
        .wall.is-hit {
            background-color: var(--wall-hit) !important;
        }

        .wall.gravitized {
            border: 2px solid #9400D3;
            box-shadow: 0 0 15px #9400D3;
            background-color: var(--wall-gravitized);
            color: var(--wall-gravitized-text);
        }

        .wall.light-infused {
            border: 2px solid #FFFF00;
            box-shadow: 0 0 15px #FFFF00;
            background-color: var(--wall-holy);
            color: #000;
        }
        
        .wall.venomized {
            border: 2px solid #00FF00;
            box-shadow: 0 0 15px #00FF00 inset;
            background-color: var(--wall-venom);
            color: #000;
        }

        .wall.singularized {
            border: 2px solid #000;
            background-color: #000;
            color: #fff;
            box-shadow: 0 0 20px #000;
            transform: scale(0.95);
        }

        .wall.being-sucked {
            transition: transform 0.2s ease-in, opacity 0.2s;
            opacity: 0.7;
        }

        .wall-label {
            position: absolute;
            left: 5px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: var(--text-dim);
            background: var(--bg-color);
            padding: 1px 3px;
            border-radius: 2px;
            border: 1px solid var(--divider-color);
        }

        /* Canvas for Balls */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
        }
        
        #trueBlackHoleVisual {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        /* UI Panels */
        .ui-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            padding: 2rem;
            border-radius: 0.5rem;
            text-align: center;
            z-index: 100;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 600px;
            color: var(--text-color);
            backdrop-filter: blur(5px);
        }

        .hidden { display: none !important; }

        h1 { letter-spacing: 2px; }

        .form-group { margin-bottom: 1.5rem; text-align: left; }
        label { display: block; color: var(--text-dim); font-size: 0.75rem; margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 1px; }
        
        select {
            width: 100%;
            background: var(--input-bg);
            border: 1px solid var(--input-border);
            color: var(--text-color);
            padding: 0.75rem;
            border-radius: 4px;
            outline: none;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            appearance: none;
            cursor: pointer;
            transition: border-color 0.2s;
        }
        select:hover { border-color: var(--text-dim); }
        select:focus { border-color: var(--text-color); }
        
        optgroup {
            background: var(--bg-color);
            color: var(--text-dim);
            font-style: normal;
            font-weight: bold;
        }
        option {
            background: var(--input-bg);
            color: var(--text-color);
            padding-left: 10px;
        }

        button.action-btn {
            width: 100%;
            background: var(--text-color);
            color: var(--bg-color);
            border: none;
            padding: 1rem;
            font-weight: bold;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
        }
        button.action-btn:hover { opacity: 0.9; }
        button.action-btn:active { transform: scale(0.98); }

        .lane-title {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-bottom: 10px;
            border-bottom: 1px solid var(--divider-color);
            padding-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>

    <!-- Header -->
    <div class="game-header">
        <div class="player-stats p1-stats">
            <div class="ball-name" id="p1Name">Player 1</div>
            <div class="ball-damage" id="p1Dmg">DMG: 0</div>
        </div>
        
        <div class="vs-badge">VS</div>
        
        <div class="player-stats p2-stats">
            <div class="ball-name" id="p2Name">Player 2</div>
            <div class="ball-damage" id="p2Dmg">DMG: 0</div>
        </div>
    </div>
    
    <button class="theme-toggle" id="themeBtn" title="Switch Theme">ğŸŒ“</button>
    <canvas id="trueBlackHoleVisual"></canvas>

    <div id="gameContainer" class="game-container">
        <div class="lane" id="lane1">
            <div class="walls-layer" id="p1Walls"></div>
            <canvas id="c1"></canvas>
        </div>
        <div class="lane-divider"></div>
        <div class="lane" id="lane2">
            <div class="walls-layer" id="p2Walls"></div>
            <canvas id="c2"></canvas>
        </div>
    </div>

    <!-- Menu -->
    <div id="menuPanel" class="ui-panel">
        <h1 class="text-2xl font-bold mb-6">ULTIMATE DUEL<br><span class="text-xs font-normal opacity-70">å¤§æ•°ç ´å£ï¼šç©¶æå¯¹å†³</span></h1>
        
        <div class="grid grid-cols-2 gap-4">
            <div class="form-group">
                <div class="lane-title">LEFT LANE</div>
                <label>Ball Type</label>
                <select id="p1Select">
                    <optgroup label=">>> åœ£å…‰ç±»å‹ (Holy Light)">
                        <option value="holyLight">åœ£å…‰çƒ (Holy Light)</option>
                        <option value="holyLight2">äºŒçº§åœ£å…‰çƒ (Holy Light Lv.2)</option>
                    </optgroup>
                    <optgroup label=">>> é€Ÿåº¦ç±»å‹ (Speed)">
                        <option value="x2Split">X2åˆ†è£‚çƒ (X2 Split)</option>
                        <option value="speed">é€Ÿåº¦çƒ (Speed Boost)</option>
                        <option value="x2Speed">X2é€Ÿåº¦çƒ (X2 Speed)</option>
                        <option value="factorialSpeed">é˜¶ä¹˜é€Ÿåº¦çƒ (Factorial Speed)</option>
                    </optgroup>
                    <optgroup label=">>> è‡ªä¹˜ç±»å‹ (Growth)">
                        <option value="factorial">è‡ªæˆ‘é˜¶ä¹˜çƒ (Factorial)</option>
                        <option value="loopDamage">å¾ªç¯ä¼¤å®³çƒ (Loop Damage)</option>
                        <option value="power">å¹‚çƒ (Power Ball)</option>
                        <option value="superFactorial">è¶…é˜¶ä¹˜çƒ (Super Factorial)</option>
                        <option value="fibonacci">æ–æ³¢é‚£å¥‘çƒ (Fibonacci)</option>
                        <option value="selfRefFibonacci">è‡ªæŒ‡æ–æ³¢é‚£å¥‘ (Self-Ref Fib)</option>
                    </optgroup>
                    <optgroup label=">>> èµŒå¾’ç±»å‹ (Gambler)">
                        <option value="godGambler">ä¸Šå¸èµŒå¾’çƒ (God Gambler)</option>
                        <option value="normalGambler">æ™®é€šèµŒå¾’çƒ (Gambler)</option>
                        <option value="madGambler">ç–¯ç‹‚èµŒå¾’çƒ (Mad Gambler)</option>
                    </optgroup>
                    <optgroup label=">>> ç‰¹æ®Šç±»å‹ (Special)">
                        <option value="sticky">ç²˜è¿çƒ (Sticky Ball)</option>
                        <option value="venomPierce">æ¯’æ¶²ç©¿é€çƒ (Venom Pierce)</option>
                        <option value="trueBlackHole">çœŸï¼šé»‘æ´çƒ (True: Black Hole)</option>
                        <option value="blackHole">é»‘æ´çƒ (Black Hole)</option>
                        <option value="absoluteVictory">ç»å¯¹èƒœåˆ©çƒ (Absolute Victory)</option>
                        <option value="infinity">æ— é™çƒ (Infinity)</option>
                        <option value="goldenRatio">é»„é‡‘åˆ†å‰²çƒ (Golden Ratio)</option>
                        <option value="percentage">ç™¾åˆ†æ¯”çƒ (Percentage)</option>
                        <option value="thousand">1000çƒ (Thousand)</option>
                    </optgroup>
                </select>
            </div>
            <div class="form-group">
                <div class="lane-title">RIGHT LANE</div>
                <label>Ball Type</label>
                <select id="p2Select">
                    <optgroup label=">>> åœ£å…‰ç±»å‹ (Holy Light)">
                        <option value="holyLight">åœ£å…‰çƒ (Holy Light)</option>
                        <option value="holyLight2">äºŒçº§åœ£å…‰çƒ (Holy Light Lv.2)</option>
                    </optgroup>
                    <optgroup label=">>> é€Ÿåº¦ç±»å‹ (Speed)">
                        <option value="x2Split">X2åˆ†è£‚çƒ (X2 Split)</option>
                        <option value="speed">é€Ÿåº¦çƒ (Speed Boost)</option>
                        <option value="x2Speed">X2é€Ÿåº¦çƒ (X2 Speed)</option>
                        <option value="factorialSpeed">é˜¶ä¹˜é€Ÿåº¦çƒ (Factorial Speed)</option>
                    </optgroup>
                    <optgroup label=">>> è‡ªä¹˜ç±»å‹ (Growth)">
                        <option value="factorial">è‡ªæˆ‘é˜¶ä¹˜çƒ (Factorial)</option>
                        <option value="loopDamage">å¾ªç¯ä¼¤å®³çƒ (Loop Damage)</option>
                        <option value="power">å¹‚çƒ (Power Ball)</option>
                        <option value="superFactorial">è¶…é˜¶ä¹˜çƒ (Super Factorial)</option>
                        <option value="fibonacci">æ–æ³¢é‚£å¥‘çƒ (Fibonacci)</option>
                        <option value="selfRefFibonacci">è‡ªæŒ‡æ–æ³¢é‚£å¥‘ (Self-Ref Fib)</option>
                    </optgroup>
                    <optgroup label=">>> èµŒå¾’ç±»å‹ (Gambler)">
                        <option value="godGambler">ä¸Šå¸èµŒå¾’çƒ (God Gambler)</option>
                        <option value="normalGambler">æ™®é€šèµŒå¾’çƒ (Gambler)</option>
                        <option value="madGambler">ç–¯ç‹‚èµŒå¾’çƒ (Mad Gambler)</option>
                    </optgroup>
                    <optgroup label=">>> ç‰¹æ®Šç±»å‹ (Special)">
                        <option value="sticky">ç²˜è¿çƒ (Sticky Ball)</option>
                        <option value="venomPierce">æ¯’æ¶²ç©¿é€çƒ (Venom Pierce)</option>
                        <option value="trueBlackHole">çœŸï¼šé»‘æ´çƒ (True: Black Hole)</option>
                        <option value="blackHole">é»‘æ´çƒ (Black Hole)</option>
                        <option value="absoluteVictory">ç»å¯¹èƒœåˆ©çƒ (Absolute Victory)</option>
                        <option value="infinity">æ— é™çƒ (Infinity)</option>
                        <option value="goldenRatio">é»„é‡‘åˆ†å‰²çƒ (Golden Ratio)</option>
                        <option value="percentage">ç™¾åˆ†æ¯”çƒ (Percentage)</option>
                        <option value="thousand">1000çƒ (Thousand)</option>
                    </optgroup>
                </select>
            </div>
        </div>

        <div class="form-group">
            <label>Difficulty Level</label>
            <select id="difficultySelect">
                <option value="superSimple">è¶…ç®€å• (Super Simple) 10^1~5</option>
                <option value="simple">ç®€å• (Simple) 10^5~7</option>
                <option value="medium">ä¸­ç­‰ (Medium) 10^9~11</option>
                <option value="hard">å›°éš¾ (Hard) 10^20~40</option>
                <option value="hell">åœ°ç‹± (Hell) 10^40~140</option>
                <option value="god">ç¥çš„æˆ˜åœº (God) 10^200~6400</option>
            </select>
        </div>

        <button id="startBtn" class="action-btn">INITIALIZE SYSTEM</button>
    </div>

    <!-- Game Over -->
    <div id="gameOverPanel" class="ui-panel hidden">
        <h1 class="text-3xl mb-2 font-bold" style="color: #ffd700;">WINNER</h1>
        <h2 id="winnerText" class="text-xl mb-6"></h2>
        <div class="text-xs opacity-70 mb-8 font-mono p-4 rounded border border-gray-600" id="statsText"></div>
        <button id="restartBtn" class="action-btn">RESTART SYSTEM</button>
    </div>

    <script>
        /**
         * Core Game Logic
         */
        
        const BIG_LIMIT = 10n ** 1000n; 
        const EXP_CAP = 12000; 

        function formatBigInt(n) {
            if (n > BIG_LIMIT) return "INFINITY";
            if (n < 1000000n) return n.toLocaleString();
            const s = n.toString();
            if (s.length < 7) return n.toString(); 
            const exponent = s.length - 1;
            const mantissa = s.substring(0, Math.min(4, s.length)); 
            if (mantissa.length > 1) {
                return `${mantissa[0]}.${mantissa.substring(1)}e${exponent}`;
            }
            return `${mantissa[0]}e${exponent}`;
        }

        const fibCache = new Map();
        fibCache.set(0n, 0n);
        fibCache.set(1n, 1n);
        
        function getFibonacci(n) {
            if (n < 0n) return 0n;
            if (fibCache.has(n)) return fibCache.get(n);
            let a = 0n, b = 1n, temp;
            return b; 
        }

        // --- Configuration ---
        const DIFFICULTIES = {
            superSimple: [1, 2, 3, 5], 
            simple: [5, 6, 7],
            medium: [9, 10, 11],
            hard: [20, 30, 40],
            hell: [40, 60, 80, 100, 120, 140],
            god: [200, 300, 400, 800, 1600, 3200, 6400] 
        };

        const BALL_TYPES = {
            x2Split: { name: "X2åˆ†è£‚çƒ", color: "#00FF00", baseDamage: 50n, speed: 1.5 }, 
            venomPierce: { name: "æ¯’æ¶²ç©¿é€çƒ", color: "#32CD32", baseDamage: 1000n, speed: 1.2 }, 
            sticky: { name: "ç²˜è¿çƒ", color: "#FFA500", baseDamage: 100n, speed: 1.2 }, 
            
            trueBlackHole: { name: "çœŸï¼šé»‘æ´çƒ", color: "#000000", baseDamage: 10n**100n, speed: 0.0 },
            blackHole: { name: "é»‘æ´çƒ", color: "#9400D3", baseDamage: 1000n, speed: 0.9 },
            holyLight: { name: "åœ£å…‰çƒ", color: "#FFFACD", baseDamage: 1000n, speed: 0.9 },
            holyLight2: { name: "äºŒçº§åœ£å…‰çƒ", color: "#FFD700", baseDamage: 2000n, speed: 0.9 }, 
            
            x2Speed: { name: "X2é€Ÿåº¦çƒ", color: "#0000FF", baseDamage: 10n, speed: 2.0 }, 
            factorialSpeed: { name: "é˜¶ä¹˜é€Ÿåº¦çƒ", color: "#FF4500", baseDamage: 1n, speed: 1.8 },
            power: { name: "å¹‚çƒ", color: "#800080", baseDamage: 2n, speed: 1.0 },
            superFactorial: { name: "è¶…é˜¶ä¹˜çƒ", color: "#8B0000", baseDamage: 1n, speed: 1.0 },
            absoluteVictory: { name: "ç»å¯¹èƒœåˆ©çƒ", color: "#FFFFFF", baseDamage: 0n, speed: 0.5 },
            loopDamage: { name: "å¾ªç¯ä¼¤å®³çƒ", color: "#32CD32", baseDamage: 100n, speed: 1.0 },

            speed: { name: "é€Ÿåº¦çƒ", color: "#00FFFF", baseDamage: 100n, speed: 1.3 },
            infinity: { name: "æ— é™çƒ", color: "#FFFFFF", baseDamage: 999n, speed: 1.0 },
            godGambler: { name: "ä¸Šå¸èµŒå¾’", color: "#FFD700", baseDamage: 1n, speed: 1.0 },
            normalGambler: { name: "æ™®é€šèµŒå¾’", color: "#FFA500", baseDamage: 1n, speed: 1.0 },
            madGambler: { name: "ç–¯ç‹‚èµŒå¾’", color: "#FF4500", baseDamage: 1n, speed: 1.0 },
            goldenRatio: { name: "é»„é‡‘åˆ†å‰²", color: "#DAA520", baseDamage: 0n, speed: 1.0 },
            fibonacci: { name: "æ–æ³¢é‚£å¥‘", color: "#00CED1", baseDamage: 1n, speed: 1.0 },
            selfRefFibonacci: { name: "è‡ªæŒ‡æ–æ³¢", color: "#20B2AA", baseDamage: 1n, speed: 1.0 },
            percentage: { name: "ç™¾åˆ†æ¯”çƒ", color: "#FF69B4", baseDamage: 0n, speed: 1.0 },
            thousand: { name: "1000çƒ", color: "#C0C0C0", baseDamage: 1000n, speed: 1.0 },
            factorial: { name: "è‡ªæˆ‘é˜¶ä¹˜", color: "#DC143C", baseDamage: 10n, speed: 1.0 }
        };

        class Wall {
            constructor(exponent, index, laneId) {
                this.exponent = exponent;
                this.maxHp = 10n ** BigInt(exponent);
                this.currentHp = this.maxHp;
                this.laneId = laneId;
                this.index = index;
                this.isBroken = false;
                
                this.el = document.createElement('div');
                this.el.className = 'wall';
                this.y = 150 + (index * 100); 
                this.el.style.top = this.y + 'px';
                
                this.label = document.createElement('div');
                this.label.className = 'wall-label';
                this.label.innerText = `10^${exponent}`;
                this.el.appendChild(this.label);
                
                this.text = document.createElement('span');
                this.text.innerText = formatBigInt(this.currentHp);
                this.el.appendChild(this.text);

                document.getElementById(laneId === 0 ? 'p1Walls' : 'p2Walls').appendChild(this.el);
                this.shakeTimer = 0;
                
                this.gravitySources = [];
                this.lightParticles = 0;
                this.venomStacks = 0;
                this.age = 0;
                this.isSucked = false;
                this.lastHp = this.currentHp;
                
                // Gambler effect
                this.gamblerTimer = 0;
                this.gamblerColor = '';
            }

            addGravityPoint(sourceBall) {
                this.gravitySources.push({ ball: sourceBall });
                this.el.classList.add('gravitized');
            }

            addLightParticle() {
                this.lightParticles++;
                this.el.classList.add('light-infused');
            }

            addVenom() {
                this.venomStacks++;
                this.el.classList.add('venomized');
            }
            
            setGamblerEffect(color) {
                this.gamblerColor = color;
                this.gamblerTimer = 30; // 0.5s visual effect
            }

            update(singularityBall = null) {
                if (this.isBroken) return;
                
                if (singularityBall && singularityBall.isSingularityActive) {
                    this.isSucked = true;
                    this.el.classList.add('being-sucked');
                    const rect = this.el.getBoundingClientRect();
                    const myX = rect.left + rect.width/2;
                    const myY = rect.top + rect.height/2;
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    const dx = centerX - myX;
                    const dy = centerY - myY;
                    this.el.style.transform = `translate(${dx * 0.1}px, ${dy * 0.1}px) scale(0.5)`;
                    if (this.age % 12 === 0) {
                        let dmg = this.maxHp / 5n; 
                        if (dmg < 1n) dmg = 1n;
                        const broken = this.takeDamage(dmg, true);
                        if (broken) singularityBall.checkWinCondition();
                    }
                    this.age++;
                    return;
                }

                this.age++;

                // Black Hole
                if (this.age % 6 === 0 && this.gravitySources.length > 0) {
                    const loss = this.lastHp - this.currentHp;
                    if (loss > 0n) this.gravitySources[0].ball.damage += loss / 10n; 
                    this.lastHp = this.currentHp;
                }
                if (this.age % 12 === 0 && this.gravitySources.length > 0) {
                    let count = BigInt(this.gravitySources.length);
                    let totalDmg = 0n;
                    if (this.currentHp > 0n) {
                        let percDmg = (this.currentHp * 25n * count) / 1000n; 
                        if (percDmg < 1n) percDmg = 1n;
                        totalDmg += percDmg;
                    }
                    if (totalDmg > 0n) {
                        const broken = this.takeDamage(totalDmg, true);
                        if (broken && this.gravitySources[0]) this.gravitySources[0].ball.onWallDestroyed(this.maxHp);
                    }
                }

                // Holy Light Particles
                if (this.lightParticles > 0) {
                    if (this.currentHp > 0n) {
                        let particleDmg = (this.currentHp * 25n) / 60000n; 
                        if (particleDmg < 1n) particleDmg = 1n;
                        particleDmg = particleDmg * BigInt(this.lightParticles);
                        this.takeDamage(particleDmg, true);
                    }
                }

                // Venom
                if (this.venomStacks > 0) {
                    if (this.currentHp > 0n) {
                        let venomDmg = (this.maxHp * 25n) / 600000n;
                        if (venomDmg < 1n) venomDmg = 1n;
                        venomDmg = venomDmg * BigInt(this.venomStacks);
                        this.takeDamage(venomDmg, true);
                    }
                }

                let renderY = this.y;
                if (this.shakeTimer > 0) {
                    renderY += (Math.random() - 0.5) * 10;
                    this.el.classList.add('is-hit'); 
                    this.shakeTimer--;
                } else {
                    this.el.classList.remove('is-hit');
                }
                
                // Apply Gambler Visuals via Inline Styles to override classes
                if (this.gamblerTimer > 0) {
                    this.gamblerTimer--;
                    this.el.style.border = `2px solid ${this.gamblerColor}`;
                    this.el.style.boxShadow = `0 0 20px ${this.gamblerColor}`;
                } else {
                    // Clear inline styles so classes can take over again if needed
                    this.el.style.border = '';
                    this.el.style.boxShadow = '';
                }
                
                if(!this.isSucked) this.el.style.transform = `translateY(${renderY - this.y}px)`;
            }

            takeDamage(amount, isDot = false) {
                if (this.isBroken) return false;
                this.currentHp -= amount;
                if (!isDot) this.shakeTimer = 5;

                if (this.currentHp <= 0n) {
                    this.currentHp = 0n;
                    this.isBroken = true;
                    this.el.style.opacity = '0';
                    setTimeout(() => this.el.remove(), 500);
                    return true; 
                }
                this.text.innerText = formatBigInt(this.currentHp);
                return false;
            }
        }

        class Ball {
            constructor(type, laneIndex, walls, canvasId) {
                this.type = type;
                this.config = BALL_TYPES[type];
                this.laneIndex = laneIndex;
                this.walls = walls;
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                this.damage = this.config.baseDamage;
                this.hits = 0;
                this.finished = false;

                this.radius = 10;
                this.x = this.canvas.width / 2;
                this.y = 50;
                
                this.baseSpeed = 8 * this.config.speed; 
                this.currentSpeedMult = 1.0; 
                
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = this.baseSpeed;

                this.tbhTimer = 0;
                this.isSingularityActive = false;
                
                if (this.type === 'trueBlackHole') {
                    this.vx = 0; this.vy = 0;
                    this.y = window.innerHeight / 3; 
                    game.triggerSingularity(this);
                }

                this.fibPrev = 1n; this.fibCurr = 1n;

                // Sticky
                this.isSticking = false;
                this.stickTimer = 0;
                this.stickTarget = null;
                this.stickDurationBase = 120; 
                this.stickCount = 0;
            }

            resize() {
                this.canvas.width = this.canvas.parentElement.clientWidth;
                this.canvas.height = this.canvas.parentElement.clientHeight;
                if (this.type === 'trueBlackHole') this.x = this.canvas.width / 2;
            }

            clone() {
                const b = new Ball(this.type, this.laneIndex, this.walls, this.canvas.id);
                b.damage = this.damage;
                b.x = this.x;
                b.y = this.y;
                b.vx = -this.vx + (Math.random() - 0.5) * 2;
                b.vy = -this.vy + (Math.random() - 0.5) * 2;
                b.hits = this.hits;
                return b;
            }

            onWallDestroyed(wallMaxHp) {
                if (this.type === 'blackHole') {
                    let multBuff = (this.damage * 2n) / 100n; 
                    this.damage += multBuff + (wallMaxHp / 2n);
                }
                if (this.type === 'holyLight' || this.type === 'holyLight2') {
                    let factor = (this.type === 'holyLight2') ? 20n : 10n;
                    let inherit = wallMaxHp * factor / 100n;
                    this.damage += inherit;
                }
                if (this.isSticking) {
                    this.isSticking = false;
                    this.vx = (Math.random() - 0.5) * 4;
                    this.vy = this.baseSpeed;
                }
            }

            checkWinCondition() {
                const allBroken = game.walls.flat().every(w => w.isBroken);
                if (allBroken) game.endGame(this);
            }

            update() {
                if (this.finished) return;

                if (this.type === 'trueBlackHole') {
                    if (this.tbhTimer < 60) {
                        this.tbhTimer++;
                        let targetY = window.innerHeight / 2;
                        this.y += (targetY - this.y) * 0.05;
                    } else {
                        this.isSingularityActive = true;
                    }
                    return;
                }

                if (this.type === 'loopDamage') this.damage += 100n; 
                if (this.type === 'absoluteVictory') { game.endGame(this); return; }

                if (this.type === 'sticky' && this.isSticking) {
                    if (this.stickTarget && this.stickTarget.isBroken) {
                        this.isSticking = false; 
                    } else {
                        this.stickTimer--;
                        if (this.stickTimer <= 0) {
                            this.isSticking = false; 
                            this.vx = (Math.random() - 0.5) * 8; 
                            this.vy = -this.baseSpeed;
                        } else {
                             if (this.stickTarget && this.stickTarget.currentHp > 0n) {
                                 let cutDmg = 100n + (this.stickTarget.currentHp * 125n) / 100000n; 
                                 const broken = this.stickTarget.takeDamage(cutDmg, true);
                                 if (broken) {
                                     this.isSticking = false;
                                     this.onWallDestroyed(this.stickTarget.maxHp);
                                 }
                             }
                             return; 
                        }
                    }
                }

                // Holy Light Aura Logic (Focused)
                if (this.type === 'holyLight' || this.type === 'holyLight2') {
                    if (game.frame % 6 === 0) {
                        const target = this.walls.find(w => !w.isBroken);
                        if (target) {
                            let base = (this.type === 'holyLight2') ? 2000n : 1000n;
                            let perc = (this.type === 'holyLight2') ? 10n : 5n;
                            let auraDmg = base + (target.currentHp * perc / 100n);
                            const broken = target.takeDamage(auraDmg, true);
                            if (broken) this.onWallDestroyed(target.maxHp);
                            else {
                                target.addLightParticle();
                                if(this.type === 'holyLight2') target.addLightParticle(); 
                            }
                        }
                    }
                }

                let speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                let stepSize = 5;
                let steps = Math.ceil(speed / stepSize) || 1;
                if(this.type === 'x2Speed' || this.type === 'factorialSpeed' || this.type === 'x2Split') steps = Math.max(steps, 8);

                for (let i = 0; i < steps; i++) {
                    if (this.finished) break;
                    if (this.isSticking) break;

                    this.x += this.vx / steps;
                    this.y += this.vy / steps;

                    if (this.x - this.radius < 0) { this.x = this.radius; this.vx *= -1; } 
                    else if (this.x + this.radius > this.canvas.width) { this.x = this.canvas.width - this.radius; this.vx *= -1; }

                    if (this.y - this.radius < 0) { this.y = this.radius; this.vy *= -1; }

                    if (this.y > this.canvas.height + 50) {
                        this.finished = true;
                        game.endGame(this);
                        break;
                    }

                    for (let w of this.walls) {
                        if (!w.isBroken) {
                            let wallX = (parseFloat(w.el.style.left) / 100) * this.canvas.width;
                            let wallW = (parseFloat(w.el.style.width) / 100) * this.canvas.width;
                            let wallY = w.y;
                            let wallH = 60;

                            let testX = this.x;
                            let testY = this.y;
                            if (this.x < wallX) testX = wallX; else if (this.x > wallX + wallW) testX = wallX + wallW;
                            if (this.y < wallY) testY = wallY; else if (this.y > wallY + wallH) testY = wallY + wallH;
                            let distX = this.x - testX;
                            let distY = this.y - testY;
                            let dist = Math.sqrt(distX*distX + distY*distY);

                            if (dist <= this.radius) {
                                this.resolveCollision(w, distX, distY);
                                if (this.isSticking) break; 
                            }
                        }
                    }
                }
            }

            resolveCollision(wall, dx, dy) {
                if (this.type === 'sticky') {
                    this.isSticking = true;
                    this.stickTarget = wall;
                    this.stickCount++;
                    this.stickTimer = this.stickDurationBase + (this.stickCount * 30); 
                    return;
                }

                let dmg = this.calculateDamage(wall);
                const broken = wall.takeDamage(dmg);
                if (broken) this.onWallDestroyed(wall.maxHp);
                this.hits++;
                
                // Trigger Gambler Visual Effect
                if (['godGambler', 'normalGambler', 'madGambler'].includes(this.type)) {
                    wall.setGamblerEffect(this.config.color);
                }

                let dist = Math.sqrt(dx*dx + dy*dy);
                let nx = dx / (dist || 1);
                let ny = dy / (dist || 1);
                let dot = this.vx * nx + this.vy * ny;
                this.vx = this.vx - 2 * dot * nx;
                this.vy = this.vy - 2 * dot * ny;
                this.x += nx * 2;
                this.y += ny * 2;
                this.vx += (Math.random() - 0.5) * 2;
                
                if (this.type === 'speed') {
                    this.currentSpeedMult *= 1.05; 
                    if(this.currentSpeedMult > 3.0) this.currentSpeedMult = 3.0; 
                }
                if (this.type === 'blackHole') wall.addGravityPoint(this);
                if (this.type === 'holyLight') wall.addLightParticle();
                if (this.type === 'holyLight2') { wall.addLightParticle(); wall.addLightParticle(); }
                
                if (this.type === 'venomPierce') {
                    this.walls.forEach(w => {
                        if (!w.isBroken) w.addVenom();
                    });
                }

                if (this.type === 'x2Split') {
                    this.damage *= 2n;
                    if (game.balls.filter(b => b.laneIndex === this.laneIndex).length < 50) {
                        game.addBall(this.clone());
                    }
                }

                let currentSpeed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                let targetBase = this.baseSpeed * this.currentSpeedMult;
                let minSpeed = targetBase * 0.8;
                let maxSpeed = targetBase * 1.5;
                if (currentSpeed < minSpeed) { this.vx *= 1.2; this.vy *= 1.2; } 
                else if (currentSpeed > maxSpeed) { this.vx *= 0.8; this.vy *= 0.8; }
            }

            calculateDamage(wall) {
                let d = 0n;
                switch (this.type) {
                    case 'sticky': d = 0n; break;
                    case 'x2Split': d = this.damage; break;
                    case 'venomPierce': d = this.damage; break;
                    case 'x2Speed': d = this.damage; this.damage *= 2n; break;
                    case 'factorialSpeed': d = this.damage; this.damage = this.damage * BigInt(this.hits + 1); break;
                    case 'power': 
                        d = this.damage; 
                        if (this.damage < BIG_LIMIT) {
                            this.damage = this.damage ** 2n; 
                        }
                        break;
                    case 'superFactorial': d = this.damage; let multiplier = BigInt(this.hits + 1); this.damage = this.damage * (multiplier * multiplier); break;
                    case 'infinity': d = wall.currentHp + 1n; break;
                    case 'holyLight': case 'holyLight2': d = this.damage; break;
                    case 'blackHole': d = this.damage; break;
                    case 'loopDamage': d = this.damage; break;
                    case 'speed': d = this.damage; this.damage += 50n; break;
                    case 'godGambler': 
                        let min = wall.currentHp / 10n;
                        if (min < 1n) min = 1n;
                        let randExp = Math.min(Math.floor(Math.random() * 100000001), EXP_CAP); 
                        let extra = 10n ** BigInt(randExp);
                        d = min + extra;
                        break;
                    case 'normalGambler':
                        let nExp = Math.min(Math.floor(Math.random() * 21), 20);
                        d = 10n ** BigInt(nExp); 
                        break;
                    case 'madGambler': 
                        let mExp = Math.min(Math.floor(Math.random() * 101), 100);
                        d = 10n ** BigInt(mExp);
                        break;
                    case 'goldenRatio': d = (wall.currentHp * 382n) / 1000n; if (d < 1n) d = 1n; break;
                    case 'fibonacci': let next = this.fibPrev + this.fibCurr; this.fibPrev = this.fibCurr; this.fibCurr = next; d = this.fibCurr; break;
                    case 'selfRefFibonacci': let nextSelf = this.fibPrev + this.fibCurr; this.fibPrev = this.fibCurr; this.fibCurr = nextSelf; this.fibPrev += this.fibCurr; d = this.fibCurr; break;
                    case 'percentage': d = (wall.currentHp * 41n) / 1000n; if (d < 1n) d = 1n; break;
                    case 'thousand': d = 1000n; break;
                    case 'factorial': d = this.damage; this.damage = (this.damage * 15n) / 10n; break;
                    default: d = this.damage; this.damage += 100n; break;
                }
                
                if (this.type === 'infinity') this.damage = 9999999999n; 
                if (this.type === 'trueBlackHole') this.damage = 10n ** 100n; 

                if (['normalGambler', 'madGambler'].includes(this.type)) {
                    this.damage = d;
                }
                
                return d;
            }

            draw() {
                if (this.type === 'trueBlackHole') return;

                this.ctx.beginPath();
                this.ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                this.ctx.fillStyle = this.config.color;
                this.ctx.fill();
                
                if (this.type === 'blackHole') {
                    this.ctx.strokeStyle = '#8A2BE2';
                    this.ctx.lineWidth = 4;
                } else if (this.type === 'sticky') {
                    this.ctx.strokeStyle = '#FFA500';
                    this.ctx.lineWidth = 3;
                    if(this.isSticking) {
                        this.ctx.shadowColor = '#FFA500';
                        this.ctx.shadowBlur = 15;
                    }
                } else if (this.type === 'venomPierce') {
                    this.ctx.strokeStyle = '#00FF00';
                    this.ctx.lineWidth = 3;
                    this.ctx.shadowColor = '#00FF00';
                    this.ctx.shadowBlur = 10;
                } else if (this.type === 'x2Split') {
                     this.ctx.strokeStyle = '#AAFFAA';
                     this.ctx.lineWidth = 2;
                } else if (this.type === 'holyLight' || this.type === 'holyLight2') {
                    this.ctx.strokeStyle = (this.type === 'holyLight2') ? '#FFD700' : '#FFFF00';
                    this.ctx.lineWidth = 2;
                    this.ctx.shadowColor = this.ctx.strokeStyle;
                    this.ctx.shadowBlur = 15;
                } else if (this.type === 'absoluteVictory') {
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = "white";
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 3;
                } else if (this.type === 'infinity') {
                    this.ctx.strokeStyle = '#000';
                    this.ctx.lineWidth = 2;
                } else {
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeStyle = '#fff'; 
                }
                
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
            }
        }

        const game = {
            active: false,
            balls: [],
            newBalls: [],
            walls: [[], []],
            loopId: null,
            frame: 0,
            singularityMode: false,

            init() {
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('restartBtn').addEventListener('click', () => this.reset());
                document.getElementById('themeBtn').addEventListener('click', () => {
                   const html = document.documentElement;
                   const current = html.getAttribute('data-theme');
                   html.setAttribute('data-theme', current === 'light' ? 'dark' : 'light');
                });
                window.addEventListener('resize', () => {
                    this.balls.forEach(b => b.resize());
                    this.resizeTrueBlackHoleCanvas();
                });
                this.resizeTrueBlackHoleCanvas();
            },

            resizeTrueBlackHoleCanvas() {
                const c = document.getElementById('trueBlackHoleVisual');
                c.width = window.innerWidth;
                c.height = window.innerHeight;
            },

            reset() {
                this.active = false;
                cancelAnimationFrame(this.loopId);
                document.getElementById('p1Walls').innerHTML = '';
                document.getElementById('p2Walls').innerHTML = '';
                document.getElementById('gameContainer').classList.remove('singularity-mode');
                document.getElementById('trueBlackHoleVisual').style.display = 'none';
                this.singularityMode = false;
                document.getElementById('gameOverPanel').classList.add('hidden');
                document.getElementById('menuPanel').classList.remove('hidden');
                const c1 = document.getElementById('c1').getContext('2d');
                const c2 = document.getElementById('c2').getContext('2d');
                c1.clearRect(0,0,10000,10000);
                c2.clearRect(0,0,10000,10000);
                this.frame = 0;
            },

            start() {
                document.getElementById('menuPanel').classList.add('hidden');
                const p1Type = document.getElementById('p1Select').value;
                const p2Type = document.getElementById('p2Select').value;
                const diffMode = document.getElementById('difficultySelect').value;
                const exponents = DIFFICULTIES[diffMode];

                this.walls = [[], []];
                this.balls = [];

                exponents.forEach((exp, i) => {
                    this.walls[0].push(new Wall(exp, i, 0));
                    this.walls[1].push(new Wall(exp, i, 1));
                });

                this.balls.push(new Ball(p1Type, 0, this.walls[0], 'c1'));
                this.balls.push(new Ball(p2Type, 1, this.walls[1], 'c2'));

                this.balls.forEach(b => b.resize());
                
                const p1Name = BALL_TYPES[p1Type].name;
                const p2Name = BALL_TYPES[p2Type].name;
                document.getElementById('p1Name').innerText = p1Name;
                document.getElementById('p1Name').style.color = BALL_TYPES[p1Type].color;
                document.getElementById('p2Name').innerText = p2Name;
                document.getElementById('p2Name').style.color = BALL_TYPES[p2Type].color;

                this.active = true;
                this.frame = 0;
                this.loop();
            },

            addBall(ball) {
                this.newBalls.push(ball);
            },

            triggerSingularity(ball) {
                this.singularityMode = true;
                document.getElementById('gameContainer').classList.add('singularity-mode');
                const overlay = document.getElementById('trueBlackHoleVisual');
                overlay.style.display = 'block';
            },

            drawTrueBlackHole(ball) {
                const ctx = document.getElementById('trueBlackHoleVisual').getContext('2d');
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                ctx.clearRect(0, 0, w, h);
                const centerX = w / 2;
                const centerY = h / 2;
                
                if (!ball.isSingularityActive) {
                    let progress = ball.tbhTimer / 60;
                    let yPos = (h/3) + (centerY - h/3) * progress;
                    ctx.save();
                    ctx.translate(centerX, yPos);
                    ctx.beginPath();
                    ctx.arc(0, 0, 20 * progress, 0, Math.PI * 2);
                    ctx.fillStyle = '#000';
                    ctx.fill();
                    ctx.restore();
                } else {
                    ctx.save();
                    ctx.translate(centerX, centerY);
                    ctx.beginPath(); ctx.arc(0, 0, 50, 0, Math.PI * 2); ctx.fillStyle = '#000'; ctx.fill();
                    ctx.beginPath(); ctx.arc(0, 0, 70, 0, Math.PI * 2); ctx.strokeStyle = '#8A2BE2'; ctx.lineWidth = 6; ctx.stroke();
                    ctx.shadowBlur = 50; ctx.shadowColor = '#4B0082'; ctx.stroke();
                    ctx.restore();
                }
            },

            loop() {
                if (!this.active) return;
                this.frame++;
                
                if (this.newBalls.length > 0) {
                    this.balls = this.balls.concat(this.newBalls);
                    this.newBalls = [];
                }

                const c1 = document.getElementById('c1').getContext('2d');
                const c2 = document.getElementById('c2').getContext('2d');
                c1.clearRect(0,0,c1.canvas.width, c1.canvas.height);
                c2.clearRect(0,0,c2.canvas.width, c2.canvas.height);
                
                let singularityBall = this.balls.find(b => b.type === 'trueBlackHole');
                if (singularityBall) {
                    this.drawTrueBlackHole(singularityBall);
                    if (singularityBall.isSingularityActive) {
                        this.balls.forEach(b => { if (b !== singularityBall) { b.vx = 0; b.vy = 0; } });
                    }
                }

                this.walls.forEach(lane => lane.forEach(w => w.update(singularityBall)));
                
                this.balls.forEach((b, i) => {
                    b.update();
                    b.draw();
                    if (i < 2) { 
                        let dmgText = "";
                        if (['godGambler','goldenRatio','percentage'].includes(b.type)) dmgText = "???";
                        else if (b.type === 'infinity' || b.type === 'trueBlackHole' || b.type === 'absoluteVictory') dmgText = "âˆ";
                        else dmgText = formatBigInt(b.damage);
                        
                        const targetId = b.laneIndex === 0 ? 'p1Dmg' : 'p2Dmg';
                        const el = document.getElementById(targetId);
                        if(el) el.innerText = `DMG: ${dmgText}`;
                    }
                });

                this.loopId = requestAnimationFrame(() => this.loop());
            },

            endGame(winnerBall) {
                this.active = false;
                cancelAnimationFrame(this.loopId);
                const panel = document.getElementById('gameOverPanel');
                const title = document.getElementById('winnerText');
                const stats = document.getElementById('statsText');
                panel.classList.remove('hidden');
                const winnerName = winnerBall.laneIndex === 0 ? "LEFT PLAYER" : "RIGHT PLAYER";
                title.innerText = winnerName;
                title.style.color = winnerBall.config.color;
                let finalDmg = (winnerBall.type === 'infinity' || winnerBall.type === 'trueBlackHole') ? "âˆ" : formatBigInt(winnerBall.damage);
                if (winnerBall.type === 'absoluteVictory') finalDmg = "INSTANT WIN";
                stats.innerHTML = `BALL: ${winnerBall.config.name}<br>FINAL DMG: ${finalDmg}`;
            }
        };

        game.init();
    </script>
</body>
</html>
