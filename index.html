<!DOCTYPE html>
<html lang="zh-CN" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Â§ßÊï∞Á†¥Â£ÅÔºöÁ©∂ÊûÅÂØπÂÜ≥</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
        
        :root {
            --bg-color: #050505;
            --lane-bg: #0a0a0a;
            --text-color: #fff;
            --text-dim: #aaa;
            --divider-color: #333;
            --wall-bg: #fff;
            --wall-text: #000;
            --wall-shadow: rgba(255,255,255,0.2);
            --wall-gravitized: #2a0a3d;
            --wall-gravitized-text: #fff;
            --wall-hit: #ffcccc;
            --panel-bg: rgba(10, 10, 10, 0.95);
            --panel-border: #333;
            --input-bg: #1a1a1a;
            --input-border: #444;
            --scanline-opacity: 0.1;
            --bubble-bg: rgba(255, 255, 255, 0.9);
            --bubble-text: #000;
        }

        [data-theme="light"] {
            --bg-color: #e0e0e0;
            --lane-bg: #f5f5f5;
            --text-color: #111;
            --text-dim: #555;
            --divider-color: #ccc;
            --wall-bg: #333;
            --wall-text: #fff;
            --wall-shadow: rgba(0,0,0,0.2);
            --wall-gravitized: #e0d0f0;
            --wall-gravitized-text: #000;
            --wall-hit: #ff9999;
            --panel-bg: rgba(255, 255, 255, 0.95);
            --panel-border: #ccc;
            --input-bg: #fff;
            --input-border: #ccc;
            --scanline-opacity: 0.03;
            --bubble-bg: rgba(0, 0, 0, 0.9);
            --bubble-text: #fff;
        }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            touch-action: none;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            transition: background-color 0.3s, color 0.3s;
        }

        /* CRT Scanline Effect */
        .scanlines {
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, var(--scanline-opacity)) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 50;
        }

        /* Header Bar */
        .game-header {
            height: 80px;
            background-color: var(--bg-color);
            border-bottom: 2px solid var(--divider-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2rem;
            z-index: 20;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            position: relative;
        }

        .player-stats {
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-width: 150px;
        }
        
        .p1-stats { align-items: flex-start; text-align: left; }
        .p2-stats { align-items: flex-end; text-align: right; }

        .vs-badge {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--text-dim);
            opacity: 0.5;
        }

        .theme-toggle {
            position: absolute;
            bottom: 20px; 
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            border: 1px solid var(--input-border);
            color: var(--text-color);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5rem;
            transition: all 0.2s;
            z-index: 60;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        .theme-toggle:hover {
            background-color: var(--input-bg);
            transform: translateX(-50%) scale(1.1);
        }

        .game-container {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 2px 1fr;
            background-color: var(--bg-color);
            position: relative;
            overflow: hidden;
            transition: all 1s ease;
        }
        
        /* True Black Hole Mode: Remove Divider */
        .game-container.singularity-mode {
             grid-template-columns: 1fr;
        }
        .game-container.singularity-mode .lane-divider {
            display: none;
        }
        .game-container.singularity-mode .lane {
            border: none;
            background: transparent;
        }

        .lane {
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background: var(--lane-bg);
            transition: background-color 0.3s;
        }

        .lane-divider {
            background: linear-gradient(to bottom, transparent, var(--divider-color), var(--divider-color), transparent);
            width: 2px;
        }

        .ball-name {
            font-size: 1.1rem;
            font-weight: bold;
            text-shadow: 0 0 5px currentColor;
        }

        .ball-damage {
            font-size: 0.9rem;
            color: var(--text-dim);
            margin-top: 4px;
            font-family: 'Courier New', Courier, monospace;
        }

        /* Walls Area */
        .walls-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .wall {
            position: absolute;
            left: 5%;
            width: 90%;
            height: 60px;
            background: var(--wall-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--wall-text);
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 0 10px var(--wall-shadow);
            transition: transform 0.1s, width 0.2s, height 0.2s, top 0.2s, left 0.2s;
            border-radius: 4px;
            z-index: 2; /* Behind ball */
        }
        
        .wall.is-hit {
            background-color: var(--wall-hit) !important;
        }

        .wall.gravitized {
            border: 2px solid #9400D3;
            box-shadow: 0 0 15px #9400D3;
            background-color: var(--wall-gravitized);
            color: var(--wall-gravitized-text);
        }

        .wall.singularized {
            border: 2px solid #000;
            background-color: #000;
            color: #fff;
            box-shadow: 0 0 20px #000;
            transform: scale(0.95);
        }

        /* True Black Hole Sucking Effect */
        .wall.being-sucked {
            transition: all 0.1s linear;
            transform: scale(0.1) rotate(720deg);
            opacity: 0.5;
        }

        .wall-label {
            position: absolute;
            left: 5px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: var(--text-dim);
            background: var(--bg-color);
            padding: 1px 3px;
            border-radius: 2px;
            border: 1px solid var(--divider-color);
        }

        /* Canvas for Balls */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
        }

        /* UI Panels (Menu/Game Over) */
        .ui-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            padding: 2rem;
            border-radius: 0.5rem;
            text-align: center;
            z-index: 100;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 600px;
            color: var(--text-color);
            backdrop-filter: blur(5px);
        }

        .hidden { display: none !important; }

        h1 { letter-spacing: 2px; }

        /* Form Elements */
        .form-group { margin-bottom: 1.5rem; text-align: left; }
        label { display: block; color: var(--text-dim); font-size: 0.75rem; margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 1px; }
        
        select {
            width: 100%;
            background: var(--input-bg);
            border: 1px solid var(--input-border);
            color: var(--text-color);
            padding: 0.75rem;
            border-radius: 4px;
            outline: none;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            appearance: none;
            cursor: pointer;
            transition: border-color 0.2s;
        }
        select:hover { border-color: var(--text-dim); }
        select:focus { border-color: var(--text-color); }
        
        optgroup {
            background: var(--bg-color);
            color: var(--text-dim);
            font-style: normal;
            font-weight: bold;
        }
        option {
            background: var(--input-bg);
            color: var(--text-color);
            padding-left: 10px;
        }

        button.action-btn {
            width: 100%;
            background: var(--text-color);
            color: var(--bg-color);
            border: none;
            padding: 1rem;
            font-weight: bold;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
        }
        button.action-btn:hover { opacity: 0.9; }
        button.action-btn:active { transform: scale(0.98); }

        .lane-title {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-bottom: 10px;
            border-bottom: 1px solid var(--divider-color);
            padding-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>

    <!-- New Header Layout -->
    <div class="game-header">
        <div class="player-stats p1-stats">
            <div class="ball-name" id="p1Name">Player 1</div>
            <div class="ball-damage" id="p1Dmg">DMG: 0</div>
        </div>
        
        <div class="vs-badge">VS</div>
        
        <div class="player-stats p2-stats">
            <div class="ball-name" id="p2Name">Player 2</div>
            <div class="ball-damage" id="p2Dmg">DMG: 0</div>
        </div>
    </div>
    
    <button class="theme-toggle" id="themeBtn" title="Switch Theme">üåì</button>

    <div id="gameContainer" class="game-container">
        <!-- Player 1 (Left) -->
        <div class="lane" id="lane1">
            <div class="walls-layer" id="p1Walls"></div>
            <canvas id="c1"></canvas>
        </div>

        <div class="lane-divider"></div>

        <!-- Player 2 (Right) -->
        <div class="lane" id="lane2">
            <div class="walls-layer" id="p2Walls"></div>
            <canvas id="c2"></canvas>
        </div>
    </div>

    <!-- Start Menu -->
    <div id="menuPanel" class="ui-panel">
        <h1 class="text-2xl font-bold mb-6">ULTIMATE DUEL<br><span class="text-xs font-normal opacity-70">Â§ßÊï∞Á†¥Â£ÅÔºöÁ©∂ÊûÅÂØπÂÜ≥</span></h1>
        
        <div class="grid grid-cols-2 gap-4">
            <div class="form-group">
                <div class="lane-title">LEFT LANE</div>
                <label>Ball Type</label>
                <select id="p1Select">
                    <optgroup label=">>> Âú£ÂÖâÁ±ªÂûã (Holy Light)">
                        <option value="holyLight">Âú£ÂÖâÁêÉ (Holy Light)</option>
                    </optgroup>
                    <optgroup label=">>> ÈÄüÂ∫¶Á±ªÂûã (Speed)">
                        <option value="speed">ÈÄüÂ∫¶ÁêÉ (Speed Boost)</option>
                        <option value="x2Speed">X2ÈÄüÂ∫¶ÁêÉ (X2 Speed)</option>
                        <option value="factorialSpeed">Èò∂‰πòÈÄüÂ∫¶ÁêÉ (Factorial Speed)</option>
                    </optgroup>
                    <optgroup label=">>> Ëá™‰πòÁ±ªÂûã (Growth)">
                        <option value="factorial">Ëá™ÊàëÈò∂‰πòÁêÉ (Factorial)</option>
                        <option value="loopDamage">Âæ™ÁéØ‰º§ÂÆ≥ÁêÉ (Loop Damage)</option>
                        <option value="power">ÂπÇÁêÉ (Power Ball)</option>
                        <option value="superFactorial">Ë∂ÖÈò∂‰πòÁêÉ (Super Factorial)</option>
                        <option value="fibonacci">ÊñêÊ≥¢ÈÇ£Â•ëÁêÉ (Fibonacci)</option>
                        <option value="selfRefFibonacci">Ëá™ÊåáÊñêÊ≥¢ÈÇ£Â•ë (Self-Ref Fib)</option>
                    </optgroup>
                    <optgroup label=">>> ËµåÂæíÁ±ªÂûã (Gambler)">
                        <option value="godGambler">‰∏äÂ∏ùËµåÂæíÁêÉ (God Gambler)</option>
                        <option value="normalGambler">ÊôÆÈÄöËµåÂæíÁêÉ (Gambler)</option>
                        <option value="madGambler">ÁñØÁãÇËµåÂæíÁêÉ (Mad Gambler)</option>
                    </optgroup>
                    <optgroup label=">>> ÁâπÊÆäÁ±ªÂûã (Special)">
                        <option value="trueBlackHole">ÁúüÔºöÈªëÊ¥ûÁêÉ (True: Black Hole)</option>
                        <option value="blackHole">ÈªëÊ¥ûÁêÉ (Black Hole)</option>
                        <option value="absoluteVictory">ÁªùÂØπËÉúÂà©ÁêÉ (Absolute Victory)</option>
                        <option value="infinity">Êó†ÈôêÁêÉ (Infinity)</option>
                        <option value="goldenRatio">ÈªÑÈáëÂàÜÂâ≤ÁêÉ (Golden Ratio)</option>
                        <option value="percentage">ÁôæÂàÜÊØîÁêÉ (Percentage)</option>
                        <option value="thousand">1000ÁêÉ (Thousand)</option>
                    </optgroup>
                </select>
            </div>
            <div class="form-group">
                <div class="lane-title">RIGHT LANE</div>
                <label>Ball Type</label>
                <select id="p2Select">
                    <optgroup label=">>> Âú£ÂÖâÁ±ªÂûã (Holy Light)">
                        <option value="holyLight">Âú£ÂÖâÁêÉ (Holy Light)</option>
                    </optgroup>
                    <optgroup label=">>> ÈÄüÂ∫¶Á±ªÂûã (Speed)">
                        <option value="speed">ÈÄüÂ∫¶ÁêÉ (Speed Boost)</option>
                        <option value="x2Speed">X2ÈÄüÂ∫¶ÁêÉ (X2 Speed)</option>
                        <option value="factorialSpeed">Èò∂‰πòÈÄüÂ∫¶ÁêÉ (Factorial Speed)</option>
                    </optgroup>
                    <optgroup label=">>> Ëá™‰πòÁ±ªÂûã (Growth)">
                        <option value="factorial">Ëá™ÊàëÈò∂‰πòÁêÉ (Factorial)</option>
                        <option value="loopDamage">Âæ™ÁéØ‰º§ÂÆ≥ÁêÉ (Loop Damage)</option>
                        <option value="power">ÂπÇÁêÉ (Power Ball)</option>
                        <option value="superFactorial">Ë∂ÖÈò∂‰πòÁêÉ (Super Factorial)</option>
                        <option value="fibonacci">ÊñêÊ≥¢ÈÇ£Â•ëÁêÉ (Fibonacci)</option>
                        <option value="selfRefFibonacci">Ëá™ÊåáÊñêÊ≥¢ÈÇ£Â•ë (Self-Ref Fib)</option>
                    </optgroup>
                    <optgroup label=">>> ËµåÂæíÁ±ªÂûã (Gambler)">
                        <option value="godGambler">‰∏äÂ∏ùËµåÂæíÁêÉ (God Gambler)</option>
                        <option value="normalGambler">ÊôÆÈÄöËµåÂæíÁêÉ (Gambler)</option>
                        <option value="madGambler">ÁñØÁãÇËµåÂæíÁêÉ (Mad Gambler)</option>
                    </optgroup>
                    <optgroup label=">>> ÁâπÊÆäÁ±ªÂûã (Special)">
                        <option value="trueBlackHole">ÁúüÔºöÈªëÊ¥ûÁêÉ (True: Black Hole)</option>
                        <option value="blackHole">ÈªëÊ¥ûÁêÉ (Black Hole)</option>
                        <option value="absoluteVictory">ÁªùÂØπËÉúÂà©ÁêÉ (Absolute Victory)</option>
                        <option value="infinity">Êó†ÈôêÁêÉ (Infinity)</option>
                        <option value="goldenRatio">ÈªÑÈáëÂàÜÂâ≤ÁêÉ (Golden Ratio)</option>
                        <option value="percentage">ÁôæÂàÜÊØîÁêÉ (Percentage)</option>
                        <option value="thousand">1000ÁêÉ (Thousand)</option>
                    </optgroup>
                </select>
            </div>
        </div>

        <div class="form-group">
            <label>Difficulty Level</label>
            <select id="difficultySelect">
                <option value="superSimple">Ë∂ÖÁÆÄÂçï (Super Simple) 10^1~5</option>
                <option value="simple">ÁÆÄÂçï (Simple) 10^5~7</option>
                <option value="medium">‰∏≠Á≠â (Medium) 10^9~11</option>
                <option value="hard">Âõ∞Èöæ (Hard) 10^20~40</option>
                <option value="hell">Âú∞Áã± (Hell) 10^40~140</option>
                <option value="god">Á•ûÁöÑÊàòÂú∫ (God) 10^200~500</option>
            </select>
        </div>

        <button id="startBtn" class="action-btn">INITIALIZE SYSTEM</button>
    </div>

    <!-- Game Over -->
    <div id="gameOverPanel" class="ui-panel hidden">
        <h1 class="text-3xl mb-2 font-bold" style="color: #ffd700;">WINNER</h1>
        <h2 id="winnerText" class="text-xl mb-6"></h2>
        <div class="text-xs opacity-70 mb-8 font-mono p-4 rounded border border-gray-600" id="statsText"></div>
        <button id="restartBtn" class="action-btn">RESTART SYSTEM</button>
    </div>

    <script>
        /**
         * Core Game Logic
         */

        // --- Utilities ---
        function formatBigInt(n) {
            if (n > 10n ** 1000n) return "INFINITY";
            if (n < 1000000n) return n.toLocaleString();
            const s = n.toString();
            if (s.length < 7) return n.toString(); 
            const exponent = s.length - 1;
            const mantissa = s.substring(0, Math.min(4, s.length)); 
            if (mantissa.length > 1) {
                return `${mantissa[0]}.${mantissa.substring(1)}e${exponent}`;
            }
            return `${mantissa[0]}e${exponent}`;
        }

        const fibCache = new Map();
        fibCache.set(0n, 0n);
        fibCache.set(1n, 1n);
        
        function getFibonacci(n) {
            if (n < 0n) return 0n;
            if (fibCache.has(n)) return fibCache.get(n);
            let a = 0n, b = 1n, temp;
            return b; 
        }

        // --- Configuration ---
        const DIFFICULTIES = {
            superSimple: [1, 2, 3, 5], 
            simple: [5, 6, 7],
            medium: [9, 10, 11],
            hard: [20, 30, 40],
            hell: [40, 60, 80, 100, 120, 140],
            god: [200, 300, 400, 450, 500, 500, 500]
        };

        const BALL_TYPES = {
            // New / Modified Balls
            trueBlackHole: { name: "ÁúüÔºöÈªëÊ¥ûÁêÉ", color: "#000000", baseDamage: 10n**100n, speed: 0.0 }, // Static but infinite range
            blackHole: { name: "ÈªëÊ¥ûÁêÉ", color: "#9400D3", baseDamage: 1000n, speed: 0.9 }, // Buffed base
            
            x2Speed: { name: "X2ÈÄüÂ∫¶ÁêÉ", color: "#0000FF", baseDamage: 10n, speed: 2.0 }, 
            factorialSpeed: { name: "Èò∂‰πòÈÄüÂ∫¶ÁêÉ", color: "#FF4500", baseDamage: 1n, speed: 1.8 },
            power: { name: "ÂπÇÁêÉ", color: "#800080", baseDamage: 2n, speed: 1.0 },
            superFactorial: { name: "Ë∂ÖÈò∂‰πòÁêÉ", color: "#8B0000", baseDamage: 1n, speed: 1.0 },
            absoluteVictory: { name: "ÁªùÂØπËÉúÂà©ÁêÉ", color: "#FFFFFF", baseDamage: 0n, speed: 0.5 },
            loopDamage: { name: "Âæ™ÁéØ‰º§ÂÆ≥ÁêÉ", color: "#32CD32", baseDamage: 100n, speed: 1.0 },

            // Existing
            speed: { name: "ÈÄüÂ∫¶ÁêÉ", color: "#00FFFF", baseDamage: 100n, speed: 1.3 },
            infinity: { name: "Êó†ÈôêÁêÉ", color: "#FFFFFF", baseDamage: 999n, speed: 1.0 },
            holyLight: { name: "Âú£ÂÖâÁêÉ", color: "#FFFACD", baseDamage: 500n, speed: 0.9 },
            godGambler: { name: "‰∏äÂ∏ùËµåÂæí", color: "#FFD700", baseDamage: 1n, speed: 1.0 },
            normalGambler: { name: "ÊôÆÈÄöËµåÂæí", color: "#FFA500", baseDamage: 1n, speed: 1.0 },
            madGambler: { name: "ÁñØÁãÇËµåÂæí", color: "#FF4500", baseDamage: 1n, speed: 1.0 },
            goldenRatio: { name: "ÈªÑÈáëÂàÜÂâ≤", color: "#DAA520", baseDamage: 0n, speed: 1.0 },
            fibonacci: { name: "ÊñêÊ≥¢ÈÇ£Â•ë", color: "#00CED1", baseDamage: 1n, speed: 1.0 },
            selfRefFibonacci: { name: "Ëá™ÊåáÊñêÊ≥¢", color: "#20B2AA", baseDamage: 1n, speed: 1.0 },
            percentage: { name: "ÁôæÂàÜÊØîÁêÉ", color: "#FF69B4", baseDamage: 0n, speed: 1.0 },
            thousand: { name: "1000ÁêÉ", color: "#C0C0C0", baseDamage: 1000n, speed: 1.0 },
            factorial: { name: "Ëá™ÊàëÈò∂‰πò", color: "#DC143C", baseDamage: 10n, speed: 1.0 }
        };

        // --- Classes ---

        class Wall {
            constructor(exponent, index, laneId) {
                this.exponent = exponent;
                this.maxHp = 10n ** BigInt(exponent);
                this.currentHp = this.maxHp;
                this.laneId = laneId;
                this.index = index;
                this.isBroken = false;
                
                this.el = document.createElement('div');
                this.el.className = 'wall';
                this.y = 150 + (index * 100); 
                this.el.style.top = this.y + 'px';
                
                this.label = document.createElement('div');
                this.label.className = 'wall-label';
                this.label.innerText = `10^${exponent}`;
                this.el.appendChild(this.label);
                
                this.text = document.createElement('span');
                this.text.innerText = formatBigInt(this.currentHp);
                this.el.appendChild(this.text);

                document.getElementById(laneId === 0 ? 'p1Walls' : 'p2Walls').appendChild(this.el);
                this.shakeTimer = 0;
                
                this.gravitySources = [];
                this.age = 0;
                this.isSucked = false; // True Black Hole effect
            }

            addGravityPoint(sourceBall) {
                this.gravitySources.push({ ball: sourceBall });
                this.el.classList.add('gravitized');
            }

            // Override update for singularity logic
            update(singularityBall = null) {
                if (this.isBroken) return;
                
                // If being sucked by True Black Hole
                if (singularityBall) {
                    this.isSucked = true;
                    this.el.classList.add('being-sucked');
                    
                    // Get Ball visual center (in global coords, lane agnostic since divider gone)
                    // Ball is in center of screen in singularity mode
                    // Let's just pull everything to center
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2; // Or ball Y
                    
                    const rect = this.el.getBoundingClientRect();
                    const myX = rect.left + rect.width/2;
                    const myY = rect.top + rect.height/2;
                    
                    // Move towards center
                    const dx = centerX - myX;
                    const dy = centerY - myY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < 50) {
                        // EATEN
                        this.takeDamage(this.maxHp * 1000n, true); // Instant kill
                        singularityBall.onWallDestroyed(this.maxHp); // Trigger win logic maybe?
                    } else {
                        // Move element visually
                        // Since we are manipulating DOM style top/left which are relative to container...
                        // This is tricky with lane relative positioning.
                        // Quick hack: Use transform translate
                        const speed = 5;
                        this.el.style.transform = `translate(${dx * 0.05}px, ${dy * 0.05}px) scale(0.8)`;
                        // Note: This is visual only, but since physics collision for true black hole 
                        // is global radius check, it's fine.
                    }
                    return;
                }

                this.age++;

                // Handle Standard Black Hole Gravity Points
                if (this.gravitySources.length > 0) {
                    let count = BigInt(this.gravitySources.length);
                    let totalDmg = 0n;

                    if (this.currentHp > 0n) {
                        // 2% per sec
                        let percDmg = (this.currentHp * count * 2n) / 6000n; 
                        if (percDmg < 1n) percDmg = 1n;
                        totalDmg += percDmg;
                    }
                    
                    // 0.2s tick = 12 frames. Apply Ball Damage.
                    if (this.age % 12 === 0) {
                        for (let source of this.gravitySources) {
                            totalDmg += source.ball.damage;
                        }
                    }

                    if (totalDmg > 0n) {
                        const broken = this.takeDamage(totalDmg, true);
                        if (broken && this.gravitySources[0]) {
                            this.gravitySources[0].ball.onWallDestroyed(this.maxHp);
                        }
                    }
                }

                let renderY = this.y;
                if (this.shakeTimer > 0) {
                    renderY += (Math.random() - 0.5) * 10;
                    this.el.classList.add('is-hit'); 
                    this.shakeTimer--;
                } else {
                    this.el.classList.remove('is-hit');
                }
                
                if(!this.isSucked) this.el.style.transform = `translateY(${renderY - this.y}px)`;
            }

            takeDamage(amount, isDot = false) {
                if (this.isBroken) return false;
                this.currentHp -= amount;
                if (!isDot) this.shakeTimer = 5;

                if (this.currentHp <= 0n) {
                    this.currentHp = 0n;
                    this.isBroken = true;
                    this.el.style.opacity = '0';
                    setTimeout(() => this.el.remove(), 500);
                    return true; 
                }
                this.text.innerText = formatBigInt(this.currentHp);
                return false;
            }
        }

        class Ball {
            constructor(type, laneIndex, walls, canvasId) {
                this.type = type;
                this.config = BALL_TYPES[type];
                this.laneIndex = laneIndex;
                this.walls = walls;
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                this.damage = this.config.baseDamage;
                this.hits = 0;
                this.finished = false;

                this.radius = 10;
                this.x = this.canvas.width / 2;
                this.y = 50;
                
                this.baseSpeed = 8 * this.config.speed; 
                this.currentSpeedMult = 1.0; 
                
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = this.baseSpeed;

                // True Black Hole Setup
                if (this.type === 'trueBlackHole') {
                    this.vx = 0;
                    this.vy = 0;
                    this.y = window.innerHeight / 3; // Sit high up
                    game.triggerSingularity(this);
                }

                this.fibPrev = 1n;
                this.fibCurr = 1n;

                this.holyPassiveTimer = 0; 
                this.holyPassiveActive = false;
                this.holyPassiveDuration = 0; 
                this.holyCharge = 0;
                this.holyUltActive = false;
                this.holyUltDuration = 0; 
            }

            resize() {
                this.canvas.width = this.canvas.parentElement.clientWidth;
                this.canvas.height = this.canvas.parentElement.clientHeight;
                if (this.type === 'trueBlackHole') {
                     this.x = this.canvas.width / 2; // Re-center
                }
            }

            onWallDestroyed(wallMaxHp) {
                if (this.type === 'blackHole') {
                    let multBuff = (this.damage * 2n) / 100n; 
                    this.damage += multBuff + wallMaxHp;
                }
                if (this.type === 'trueBlackHole') {
                    // True Black Hole wins immediately on consuming anything (per prompt "eats wall direct victory")
                    game.endGame(this);
                }
            }

            update() {
                if (this.finished) return;

                // True Black Hole Logic
                if (this.type === 'trueBlackHole') {
                    // It doesn't move physically, it just sits there and sucks
                    // Logic handled in Wall.update via game loop passing this ball
                    return;
                }

                // Loop Damage Logic
                if (this.type === 'loopDamage') {
                    this.damage += 100n; 
                }

                // Absolute Victory Check
                if (this.type === 'absoluteVictory') {
                    game.endGame(this);
                    return;
                }

                // Black Hole Aura Logic
                if (this.type === 'blackHole') {
                    // 0.01s damage (~every frame)
                    // Check aura collision with walls
                    for (let w of this.walls) {
                        if (!w.isBroken) {
                            let wx = parseFloat(w.el.style.left) / 100 * this.canvas.width;
                            let wy = w.y;
                            // Simple dist check to wall center
                            let dist = Math.sqrt((this.x - (wx+w.el.clientWidth/2))**2 + (this.y - (wy+30))**2);
                            if (dist < this.radius * 4) { // Aura radius
                                w.takeDamage(this.damage, true); // True Damage tick
                            }
                        }
                    }
                }

                // Holy Light Passive
                if (this.type === 'holyLight') {
                    this.holyPassiveTimer++;
                    if (this.holyPassiveTimer >= 180) {
                        this.holyPassiveActive = true;
                        this.holyPassiveDuration = 60; 
                        this.holyPassiveTimer = 0;
                    }

                    if (this.holyPassiveActive) {
                        this.holyPassiveDuration--;
                        if (this.holyPassiveDuration % 6 === 0) {
                            this.applyHolyAuraDamage(1000n, 100); 
                        }
                        if (this.holyPassiveDuration <= 0) {
                            this.holyPassiveActive = false;
                        }
                    }

                    if (this.holyUltActive) {
                        this.holyUltDuration--;
                        let dmgPerFrame = 10000n / 60n; 
                        if (dmgPerFrame < 1n) dmgPerFrame = 1n;
                        this.applyHolyAuraDamage(dmgPerFrame, 200); 
                        
                        if (this.holyUltDuration <= 0) {
                            this.holyUltActive = false;
                            this.holyCharge = 0;
                        }
                    }
                }

                // Sub-stepping for high speed
                let speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                let stepSize = 5;
                let steps = Math.ceil(speed / stepSize) || 1;
                
                if(this.type === 'x2Speed' || this.type === 'factorialSpeed') steps = Math.max(steps, 8);

                for (let i = 0; i < steps; i++) {
                    if (this.finished) break;

                    this.x += this.vx / steps;
                    this.y += this.vy / steps;

                    // Bounds
                    if (this.x - this.radius < 0) {
                        this.x = this.radius;
                        this.vx *= -1;
                    } else if (this.x + this.radius > this.canvas.width) {
                        this.x = this.canvas.width - this.radius;
                        this.vx *= -1;
                    }

                    if (this.y - this.radius < 0) {
                        this.y = this.radius;
                        this.vy *= -1;
                    }

                    if (this.y > this.canvas.height + 50) {
                        this.finished = true;
                        game.endGame(this);
                        break;
                    }

                    // Wall Collision
                    for (let w of this.walls) {
                        if (!w.isBroken) {
                            let wallX = (parseFloat(w.el.style.left) / 100) * this.canvas.width;
                            let wallW = (parseFloat(w.el.style.width) / 100) * this.canvas.width;
                            let wallY = w.y;
                            let wallH = 60;

                            let testX = this.x;
                            let testY = this.y;

                            if (this.x < wallX) testX = wallX;
                            else if (this.x > wallX + wallW) testX = wallX + wallW;
                            
                            if (this.y < wallY) testY = wallY;
                            else if (this.y > wallY + wallH) testY = wallY + wallH;

                            let distX = this.x - testX;
                            let distY = this.y - testY;
                            let dist = Math.sqrt(distX*distX + distY*distY);

                            if (dist <= this.radius) {
                                this.resolveCollision(w, distX, distY);
                            }
                        }
                    }
                }
            }

            applyHolyAuraDamage(amount, range) {
                for (let w of this.walls) {
                    if (!w.isBroken) {
                        let dy = Math.abs(this.y - (w.y + 30)); 
                        if (dy < range) {
                            w.takeDamage(amount, true);
                        }
                    }
                }
            }

            resolveCollision(wall, dx, dy) {
                let dmg = this.calculateDamage(wall);
                const broken = wall.takeDamage(dmg);
                if (broken && (this.type === 'blackHole')) {
                    this.onWallDestroyed(wall.maxHp);
                }
                this.hits++;

                let dist = Math.sqrt(dx*dx + dy*dy);
                let nx = dx / (dist || 1);
                let ny = dy / (dist || 1);

                let dot = this.vx * nx + this.vy * ny;
                this.vx = this.vx - 2 * dot * nx;
                this.vy = this.vy - 2 * dot * ny;

                this.x += nx * 2;
                this.y += ny * 2;

                this.vx += (Math.random() - 0.5) * 2;
                
                if (this.type === 'speed') {
                    this.currentSpeedMult *= 1.05; 
                    if(this.currentSpeedMult > 3.0) this.currentSpeedMult = 3.0; 
                }
                
                if (this.type === 'blackHole') {
                    wall.addGravityPoint(this);
                }
                
                if (this.type === 'holyLight') {
                    this.holyCharge++;
                    if (this.holyCharge >= 10) {
                        this.holyUltActive = true;
                        this.holyUltDuration = 180; 
                        this.holyCharge = 0; 
                    }
                }

                let currentSpeed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                let targetBase = this.baseSpeed * this.currentSpeedMult;
                
                let minSpeed = targetBase * 0.8;
                let maxSpeed = targetBase * 1.5;
                
                if (currentSpeed < minSpeed) {
                    this.vx *= 1.2;
                    this.vy *= 1.2;
                } else if (currentSpeed > maxSpeed) {
                    this.vx *= 0.8;
                    this.vy *= 0.8;
                }
            }

            calculateDamage(wall) {
                let d = 0n;
                switch (this.type) {
                    case 'x2Speed':
                        d = this.damage;
                        this.damage *= 2n;
                        break;

                    case 'factorialSpeed':
                        d = this.damage;
                        this.damage = this.damage * BigInt(this.hits + 1);
                        break;

                    case 'power':
                        d = this.damage;
                        this.damage = this.damage ** 2n;
                        break;

                    case 'superFactorial':
                        d = this.damage;
                        let multiplier = BigInt(this.hits + 1);
                        this.damage = this.damage * (multiplier * multiplier);
                        break;

                    case 'infinity':
                        d = wall.currentHp + 1n; 
                        break;

                    case 'holyLight':
                        d = this.damage;
                        break;

                    case 'blackHole':
                        d = this.damage; 
                        break;
                    
                    case 'loopDamage':
                        d = this.damage;
                        break;

                    case 'speed':
                        d = this.damage;
                        this.damage += 50n;
                        break;
                    
                    case 'godGambler':
                        let min = wall.currentHp / 10n;
                        if (min < 1n) min = 1n;
                        let randExp = Math.floor(Math.random() * 1001); 
                        let extra = 10n ** BigInt(randExp);
                        d = min + extra;
                        break;

                    case 'normalGambler':
                        d = BigInt(Math.floor(Math.random() * 10000000) + 1); 
                        break;
                    
                    case 'madGambler':
                        d = BigInt(Math.floor(Math.random() * 1000000000) + 1); 
                        break;

                    case 'goldenRatio':
                        d = (wall.currentHp * 382n) / 1000n;
                        if (d < 1n) d = 1n;
                        break;

                    case 'fibonacci':
                        let next = this.fibPrev + this.fibCurr;
                        this.fibPrev = this.fibCurr;
                        this.fibCurr = next;
                        d = this.fibCurr;
                        break;
                    
                    case 'selfRefFibonacci':
                        let nextSelf = this.fibPrev + this.fibCurr;
                        this.fibPrev = this.fibCurr;
                        this.fibCurr = nextSelf;
                        this.fibPrev += this.fibCurr; 
                        d = this.fibCurr;
                        break;

                    case 'percentage':
                        d = (wall.currentHp * 41n) / 1000n;
                        if (d < 1n) d = 1n;
                        break;

                    case 'thousand':
                        d = 1000n;
                        break;

                    case 'factorial':
                        d = this.damage;
                        this.damage = (this.damage * 15n) / 10n;
                        break;

                    default:
                        d = this.damage;
                        this.damage += 100n; 
                        break;
                }
                
                if (this.type === 'infinity') this.damage = 9999999999n; 
                if (this.type === 'trueBlackHole') this.damage = 10n ** 100n; 
                
                return d;
            }

            draw() {
                if (this.type === 'trueBlackHole') {
                    // Special central drawing
                    // Use global coords approx
                    // Actually, use this.x/y. If centered, it's width/2.
                    this.ctx.save();
                    this.ctx.translate(this.x, this.y);
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 40, 0, Math.PI * 2); // Big center
                    this.ctx.fillStyle = '#000';
                    this.ctx.fill();
                    // Accretion Disk
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 60, 0, Math.PI * 2);
                    this.ctx.strokeStyle = '#A020F0';
                    this.ctx.lineWidth = 5;
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 50;
                    this.ctx.shadowColor = '#4B0082';
                    this.ctx.stroke();
                    this.ctx.restore();
                    return;
                }

                this.ctx.beginPath();
                this.ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                this.ctx.fillStyle = this.config.color;
                this.ctx.fill();
                
                // Visual flair
                if (this.type === 'blackHole') {
                    this.ctx.strokeStyle = '#8A2BE2';
                    this.ctx.lineWidth = 4;
                    // Draw Aura
                    this.ctx.beginPath();
                    this.ctx.arc(this.x, this.y, this.radius * 4, 0, Math.PI*2);
                    this.ctx.strokeStyle = 'rgba(138, 43, 226, 0.3)';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                } else if (this.type === 'loopDamage') {
                    this.ctx.strokeStyle = '#00FF00';
                    this.ctx.lineWidth = 3;
                } else if (this.type === 'holyLight') {
                    this.ctx.strokeStyle = '#FFFF00';
                    this.ctx.lineWidth = 2;
                    if (this.holyPassiveActive) {
                         this.ctx.beginPath();
                         this.ctx.arc(this.x, this.y, this.radius + 10 + Math.random()*5, 0, Math.PI*2);
                         this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                         this.ctx.stroke();
                    }
                    if (this.holyUltActive) {
                         this.ctx.beginPath();
                         this.ctx.arc(this.x, this.y, this.radius + 40 + Math.random()*10, 0, Math.PI*2);
                         this.ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                         this.ctx.fill();
                         this.ctx.strokeStyle = '#FFD700';
                         this.ctx.stroke();
                    }
                } else if (this.type === 'absoluteVictory') {
                    // Shining white
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = "white";
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 3;
                } else if (this.type === 'infinity') {
                    this.ctx.strokeStyle = '#000';
                    this.ctx.lineWidth = 2;
                } else {
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeStyle = '#fff'; 
                }
                
                this.ctx.stroke();
                this.ctx.shadowBlur = 0; // Reset

                // Inner detail
                this.ctx.beginPath();
                this.ctx.moveTo(this.x - this.radius, this.y);
                this.ctx.lineTo(this.x + this.radius, this.y);
                this.ctx.strokeStyle = (this.type === 'infinity') ? '#000' : '#000';
                this.ctx.stroke();
            }
        }

        // --- Game Controller ---

        const game = {
            active: false,
            balls: [],
            walls: [[], []],
            loopId: null,
            frame: 0,
            singularityMode: false,

            init() {
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('restartBtn').addEventListener('click', () => this.reset());
                
                document.getElementById('themeBtn').addEventListener('click', () => {
                   const html = document.documentElement;
                   const current = html.getAttribute('data-theme');
                   html.setAttribute('data-theme', current === 'light' ? 'dark' : 'light');
                });

                window.addEventListener('resize', () => {
                    this.balls.forEach(b => b.resize());
                });
            },

            reset() {
                this.active = false;
                cancelAnimationFrame(this.loopId);
                
                document.getElementById('p1Walls').innerHTML = '';
                document.getElementById('p2Walls').innerHTML = '';
                document.getElementById('gameContainer').classList.remove('singularity-mode');
                this.singularityMode = false;
                
                document.getElementById('gameOverPanel').classList.add('hidden');
                document.getElementById('menuPanel').classList.remove('hidden');
                
                const c1 = document.getElementById('c1').getContext('2d');
                const c2 = document.getElementById('c2').getContext('2d');
                c1.clearRect(0,0,10000,10000);
                c2.clearRect(0,0,10000,10000);
                this.frame = 0;
            },

            start() {
                document.getElementById('menuPanel').classList.add('hidden');
                
                const p1Type = document.getElementById('p1Select').value;
                const p2Type = document.getElementById('p2Select').value;
                const diffMode = document.getElementById('difficultySelect').value;
                const exponents = DIFFICULTIES[diffMode];

                this.walls = [[], []];
                this.balls = [];

                // Create Walls
                exponents.forEach((exp, i) => {
                    this.walls[0].push(new Wall(exp, i, 0));
                    this.walls[1].push(new Wall(exp, i, 1));
                });

                // Create Balls
                this.balls.push(new Ball(p1Type, 0, this.walls[0], 'c1'));
                this.balls.push(new Ball(p2Type, 1, this.walls[1], 'c2'));

                this.balls.forEach(b => b.resize());
                
                // Update UI Names
                document.getElementById('p1Name').innerText = BALL_TYPES[p1Type].name;
                document.getElementById('p1Name').style.color = BALL_TYPES[p1Type].color;
                
                document.getElementById('p2Name').innerText = BALL_TYPES[p2Type].name;
                document.getElementById('p2Name').style.color = BALL_TYPES[p2Type].color;

                this.active = true;
                this.frame = 0;
                this.loop();
            },

            triggerSingularity(ball) {
                this.singularityMode = true;
                document.getElementById('gameContainer').classList.add('singularity-mode');
                ball.x = window.innerWidth / 2;
                // Don't set Y here, let Ball constructor handle or let it be centered
                ball.y = window.innerHeight / 2;
            },

            loop() {
                if (!this.active) return;
                this.frame++;

                this.balls.forEach(b => b.ctx.clearRect(0,0, b.canvas.width, b.canvas.height));
                
                // Special handling for singularity: Both lanes update, but visually they are sucked
                let singularityBall = this.balls.find(b => b.type === 'trueBlackHole');

                // Update walls (Singularity affects ALL walls)
                this.walls.forEach(lane => lane.forEach(w => w.update(singularityBall)));
                
                this.balls.forEach((b, i) => {
                    b.update();
                    b.draw();
                    let dmgText = "";
                    if (['godGambler','goldenRatio','percentage'].includes(b.type)) {
                        dmgText = "???";
                    } else if (b.type === 'infinity') {
                        dmgText = "‚àû";
                    } else if (b.type === 'absoluteVictory' || b.type === 'trueBlackHole') {
                        dmgText = "‚àû";
                    } else {
                        dmgText = formatBigInt(b.damage);
                    }
                    document.getElementById(i===0 ? 'p1Dmg' : 'p2Dmg').innerText = `DMG: ${dmgText}`;
                });

                this.loopId = requestAnimationFrame(() => this.loop());
            },

            endGame(winnerBall) {
                this.active = false;
                cancelAnimationFrame(this.loopId);
                
                const panel = document.getElementById('gameOverPanel');
                const title = document.getElementById('winnerText');
                const stats = document.getElementById('statsText');
                
                panel.classList.remove('hidden');
                
                const winnerName = winnerBall.laneIndex === 0 ? "LEFT PLAYER" : "RIGHT PLAYER";
                title.innerText = winnerName;
                title.style.color = winnerBall.config.color;
                
                let finalDmg = (winnerBall.type === 'infinity' || winnerBall.type === 'trueBlackHole') ? "‚àû" : formatBigInt(winnerBall.damage);
                if (winnerBall.type === 'absoluteVictory') finalDmg = "INSTANT WIN";

                stats.innerHTML = `
                    BALL: ${winnerBall.config.name}<br>
                    HITS: ${winnerBall.hits}<br>
                    FINAL DMG: ${finalDmg}
                `;
            }
        };

        game.init();

    </script>
</body>
</html>
